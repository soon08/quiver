{
  "title": "sync",
  "cells": [
    {
      "type": "text",
      "data": "<div><b>互斥锁——sync.Mutex</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;在并发编程中，某个逻辑片段往往不同同时进行，需要被保护起来实现类似原子性的操作，这个时候就需要用到互斥锁。互斥锁能实现在代码临界区内只能有一个执行。在Golang中，互斥锁使用sync.Mutex实现。</div>"
    },
    {
      "type": "code",
      "language": "golang",
      "data": "var mutex sync.Mutex\nfunc handle(){\n   mutex.Lock()\n   //一系列不能分割操作\n   mutex.Unlock()\n}\n\ngo handle()\ngo handle()"
    },
    {
      "type": "text",
      "data": "<div><b>读写锁——sync.RWMutex</b></div><div>&nbsp; &nbsp; &nbsp; &nbsp;互斥锁有时并不能满足一些特殊的需求，如针对某些数据，读操作之间是可以并发进行的，但写操作之间不能并发进行，在读操作运行期间写操作不行进行。针对这些特殊需求，有了读写锁的概念，它能做到如下保护，同时能保证最高的性能：</div><div><ol><li>写与写互斥——在写数据的时候是不允许其他写操作对该数据同时进行的</li><li>写与读互斥——在写数据的时候是不允许其他读操作对该数据同时进行的</li><li>读与写互斥——在读数据的时候是不允许其他写操作对该数据同时进行的</li></ol><div>&nbsp; &nbsp; &nbsp; 互斥锁使用的场景是在互斥锁保护的代码临界区内只能有一个操作进入临界区执行，读写锁针对的场景是对数据读写的保护，读写锁典型的使用场景就是在生产者和消费者的使用场景。生产者写入数据时，消费者不能读取数据，同时其他生产者也不能写入数据。当消费者消费数据时，其他消费者可以消费数据，但生产者不能写入数据。</div></div><div>&nbsp; &nbsp; &nbsp; 在Golang中读写锁，使用sync.RWMutex实现，有四个方法</div><div><ol><li>func (m *RWMtuex) Lock()——写锁定，阻塞其他写操作和读操作</li><li>func (m *RWMtuex) Unlock()——写解锁</li><li>func (m *RWMtuex) RLock()——读锁定，阻塞其他写操作</li><li>func (m *RWMtuex) RUnlock()——读解锁</li></ol></div>"
    },
    {
      "type": "code",
      "language": "golang",
      "data": ""
    },
    {
      "type": "text",
      "data": "<b>原子操作——sync/atomic</b><div>&nbsp; &nbsp; &nbsp; 原子操作就是不能不中断的操作，也就是说在执行这个操作的时候，CPU不能转而去执行其他的操作。在Golang中，原子操作使用sync/atomic实现，能实现对数字增减、交换、载入、存储的原子操作。</div>"
    },
    {
      "type": "text",
      "data": "<b>只执行一次——sync.Once</b><div><b>&nbsp; &nbsp; &nbsp; </b>传入sync.Once对象的Do方法中的是一个无参数，无返回的函数．sync.Once对象能保证传入Do方法的函数只能被执行一次</div>"
    },
    {
      "type": "code",
      "language": "golang",
      "data": "package main\n\nimport (\n\t\"sync\"\n)\n\nfunc main() {\n\tvar once sync.Once\n\t\n\tfor i := 0; i < 10; i++ {\n\t\tonce.Do(func(){\n\t\t\tprintln(\"Once!\")\n\t\t})\n\t}\n}"
    },
    {
      "type": "text",
      "data": "<b>零时对象池——sync.Pool</b><div><b>&nbsp; &nbsp; &nbsp; </b>有时我们需要一个对象池，sync.Pool类型值可以看作存放可被重复使用的值的容器。该容器是自动伸缩、高效的，同时也是并发安全的。</div><div>&nbsp; &nbsp; &nbsp; 该结构体有一个属性New func() interface{}, 是在对象池中无对象可用时才会被调用。</div><div>&nbsp; &nbsp; &nbsp; 该结构体有两个方法 Get() interface{} 和 Put(obj interface{}), 如果调用Get方法是，New没有赋值，且也没有调用过Put方法，那么Get方法一定返回的是nil。&nbsp;</div><div>&nbsp; &nbsp; &nbsp; 临时对象池中的对象对垃圾回收是友好的，会在垃圾回收是被回收。所以对于Get返回的对象不应该有任何假设，所以我们通过Put方法存入的对象应该是无状态的或者是状态一直的对象。</div>"
    },
    {
      "type": "text",
      "data": "<b>条件变量——sync.Cond</b><div>&nbsp; &nbsp; &nbsp; 在多线程编程中，虽然已经有了互斥量保证临界区内代码不会存在并发问题。但是其他线程或者协程会频繁尝试进入临街保护区，这会导致程序效能低下。如果有一种机制，能保证没有获取互斥量的其他线程或者协程在没有得到通知的情况下不尝试进入临街保护区，而在得到正在执行的线程释放互斥量通知的情况下才进入，就会避免很多不必要的线程切换。条件变量正是为这个需求而准备的。</div><div>&nbsp; &nbsp; &nbsp; 创建条件变量需要一个互斥量，func NewCond(l locker) *Cond, 条件互斥量存在三个方法。</div><div><ol><li>Wait &nbsp;自动解锁与之关联的那个锁，并使调用Wait方法所在goroutine被阻塞</li><li>Singal &nbsp;通知某个协程激活</li><li>Broadcast &nbsp;通知所有协程激活</li></ol></div>"
    },
    {
      "type": "code",
      "language": "golang",
      "data": "package main\n\nimport(\n\t\"sync\"\n)\n\nvar wg sync.WaitGroup\n\nvar mutex sync.Locker = &sync.Mutex{}\n\nvar cond *sync.Cond = sync.NewCond(mutex)\n\nvar data = make(map[int]int)\n\nvar count int = 0\n\nfunc producter() {\n\tmutex.Lock()\n\tfor {\n\t\tif len(data) == 10 {\n\t\t\tcond.Signal()  //通知其他线程\n\t\t\tcond.Wait()    //释放锁同时等待其他线程,注意顺序不能调整\n\t\t}else{\n\t\t\tdata[count] = 10\n\t\t\tcount++\n\t\t}\n\t}\n\tmutex.Unlock()\n\twg.Done()\n}\n\nfunc consumer(){\n\tmutex.Lock()\n\tfor {\n\t\tif len(data) == 0 {\n\t\t\tcond.Wait()  //释放锁等待其他线程\n\t\t}else{\n\t\t\tfor key, val := range data {\n\t\t\t\tprintln(key, val)\n\t\t\t\tdelete(data, key)\n\t\t\t}\n\t\t\tcond.Signal() //通知其他线程\n\t\t}\n\t}\n\tmutex.Unlock()\n\twg.Done()\n}\n\nfunc main() {\n\t\n\twg.Add(2)\n\t\n\tgo producter()\n\tgo consumer()\n\t\n\twg.Wait()\n\t\n\tprintln(\"end\")\n\t\n}"
    },
    {
      "type": "text",
      "data": "<b>多协程同步——sync.WaitGroup</b><div>&nbsp; &nbsp; &nbsp; 由于协程是异步运行的，当有多个协程同时在运行时，如何等待多个协程完成。进一步的如何控制协程之间的流程。sync.WaitGroup的实现就是为了解决这个问题的。</div><br><h4 cid=\"c7\" mdtype=\"heading\" class=\"md-end-block md-heading\" style=\"line-height: 1.4; box-sizing: border-box; font-size: 1.25em; position: relative; margin-top: 1rem; margin-bottom: 1rem; cursor: text; width: inherit; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">线程同步的方法</span></h4><ul class=\"ul-list\" cid=\"c8\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0.8em 0px; padding-left: 30px; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><li cid=\"c9\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c10\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c11\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">原子操作</span></span></p></li><li cid=\"c12\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c13\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c14\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">互斥量 —— 只允许一个线程处于临界区的约束被称为互斥量（mutex）</span></span></p><ul class=\"ul-list\" cid=\"c15\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0px; padding-left: 30px;\"><li cid=\"c16\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c17\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c18\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">每个线程进入该代码区域的时候都需要先锁定这个互斥量，否则无法进入，只能等待</span></span></p></li><li cid=\"c19\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c20\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c21\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">线程离开临界区的时候需要解锁该互斥量，此时其他线程才可以成功锁定该互斥量</span></span></p></li><li cid=\"c22\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c23\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c24\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">互斥量也属于共享资源，能被其他线程访问，所以互斥量一般都不是局部的</span></span></p></li><li cid=\"c25\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c26\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c27\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">尽量不要让不同互斥量保护的临界区重叠，这很可能会照成死锁，即使要也要使获取互斥量的顺序相同</span></span></p></li></ul></li><li cid=\"c28\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c29\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c30\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量——在共享数据发生变化时，通知其他因此而阻塞的线程</span></span></p><ul class=\"ul-list\" cid=\"c31\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0px; padding-left: 30px;\"><li cid=\"c32\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c33\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c34\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量总是和互斥量共同使用，互斥量用于提供临界区保护，条件变量用于向其他线程通知共享变量的变化</span></span></p></li></ul><blockquote cid=\"c35\" mdtype=\"blockquote\" style=\"margin-top: 0.8em; margin-bottom: 0.8em; box-sizing: border-box;\"><p cid=\"c36\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0px 0px 0.5rem; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c37\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量的使用场景</span></span></p><p cid=\"c38\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c39\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">有一个共享队列，多个消费者从队列中并发读取数据，同时又多个生产者并发这向队列中写入数据。生产者写入数据前会先获取一个锁，判断队列是否满，如果满那么就直接解锁，否者向队列写入数据。消费者在获取数据前，会先获取一个锁，判断队列是否为空，如果为空直接解锁，否者从队列中取出一个数据。这个过程中，如果队列已满，生产者会重复获取释放锁，但是却没有写入任何数据。如果队列为空，消费者会重复获取和释放锁，但是却没有获取到任何数据。这会造成CPU资源浪费。</span></span></p><p cid=\"c40\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c41\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量就是在这种情况下产生的，避免生产者或者消费者重复获取和释放锁。</span></span></p><p cid=\"c42\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c43\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量根据一个锁创建的，如果生产者不满足条件，会先释放锁，并将线程阻塞，当条件变量获取到激活通知后，重新获取锁，并将阻塞的线程激活。</span></span></p></blockquote></li></ul><h4 cid=\"c44\" mdtype=\"heading\" class=\"md-end-block md-heading\" style=\"line-height: 1.4; box-sizing: border-box; font-size: 1.25em; position: relative; margin-top: 1rem; margin-bottom: 1rem; cursor: text; width: inherit; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">优化并发性能</span></h4><ul class=\"ul-list\" cid=\"c45\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0.8em 0px 0px; padding-left: 30px; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><li cid=\"c46\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c47\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c48\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">控制临界区纯度，将不需要同步的代码屏蔽在外</span></span></p></li><li cid=\"c49\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c50\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c51\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">控制临界区粒度，尽量合并相邻的多个临界区为一个临界区，减少协调发生次数</span></span></p></li><li cid=\"c52\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c53\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c54\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">减少临界区中的代码执行时间，将执行时间长的代码单独到一个临界区</span></span></p></li><li cid=\"c55\" mdtype=\"list_item\" class=\"\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c56\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block md-focus\" cid=\"c57\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">优先使用原子操作而不是临界区</span></span></p></li></ul>"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}