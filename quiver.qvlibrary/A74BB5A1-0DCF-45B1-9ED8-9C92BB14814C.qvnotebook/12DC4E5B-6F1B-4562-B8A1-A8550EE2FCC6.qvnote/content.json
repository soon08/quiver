{
  "title": "Docker 简介",
  "cells": [
    {
      "type": "text",
      "data": "<div><br></div><div><img src=\"quiver-image-url/6D415A61EFE9DEB7BA9B1AF10312A292.jpg\"><br></div>docker组件<div><ul><li>Docker客户端和服务器</li><li>Docker镜像</li><li>Registry</li><li>Docker容器</li></ul></div>"
    },
    {
      "type": "text",
      "data": "客户端和服务器：<div><ul><li>Docker提供了命令行工具用于向Docker服务器发送命令</li><li>Docker还提供了一整套的RESTful API</li></ul></div>"
    },
    {
      "type": "text",
      "data": "镜像<div><ul><li>镜像是基于联合（UNION）文件系统的一种层式结构，由一系列指令一步步构建出来</li><ul><li>添加一个文件</li><li>打开一个命令</li><li>打开一个端口</li></ul></ul></div>"
    },
    {
      "type": "text",
      "data": "Registry<div><ul><li>公有镜像</li><li>私有镜像</li></ul></div>"
    },
    {
      "type": "text",
      "data": "容器<div><ul><li>容器可以运行一个或者多个进程</li></ul></div>"
    },
    {
      "type": "text",
      "data": "Docker能做什么<div><ul><li>容器可以在开发环境中构建，然后轻松的移交到测试环境，并最终进入生产环境</li><li>能够让独立的服务或者应用程序在不同的环境中得到相同的运行结果</li><li>用Docker来创建隔离的测试环境用于测试</li><li>Docker可以帮助开发人员轻松构建架构环境</li><li>构建PaaS基础设施</li><li>构建SaaS服务</li><li>高性能超大规模的宿主机部署</li></ul></div>"
    },
    {
      "type": "text",
      "data": "Docker清理命令<div><span style=\"color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; line-height: 25.2px; widows: 1; background-color: rgb(221, 237, 251);\">docker kill $(docker ps -a -q)&nbsp;</span><span style=\"color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; widows: 1; background-color: rgb(255, 255, 255);\">杀死所有正在运行的容器</span><br></div><div><span style=\"color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; line-height: 25.2px; widows: 1; background-color: rgb(221, 237, 251);\"><span style=\"line-height: 25.2px;\">docker rm $(docker ps -a -q)&nbsp;</span><span style=\"background-color: rgb(255, 255, 255);\">删除所有已经停止的容器</span><br></span></div><div><span style=\"color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; line-height: 25.2px; widows: 1; background-color: rgb(221, 237, 251);\"><span style=\"line-height: 25.2px;\"><span style=\"line-height: 25.2px;\">docker rmi $(docker images -q -f dangling=true)&nbsp;</span><span style=\"background-color: rgb(255, 255, 255);\">&nbsp;删除所有未打 dangling 标签的镜像</span><br></span></span></div><div><span style=\"color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; line-height: 25.2px; widows: 1; background-color: rgb(221, 237, 251);\"><span style=\"line-height: 25.2px;\"><span style=\"line-height: 25.2px;\"><span style=\"line-height: 25.2px;\">docker rmi $(docker images -q)&nbsp;</span><span style=\"background-color: rgb(255, 255, 255);\">&nbsp;删除所有镜像</span><br></span></span></span></div>"
    },
    {
      "type": "text",
      "data": "<h3 style=\"padding: 0px; margin: 5px auto; line-height: 25.2px; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; widows: 1; background-color: rgb(250, 250, 250);\">1.5 命名空间「Namespaces」</h3><h4 style=\"padding: 0px; margin: 5px auto; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\">pid namespace</h4><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">不同用户的进程就是通过 pid namespace 隔离开的，且不同 namespace 中可以有相同 PID。具有以下特征:</p><ul style=\"padding: 0px; margin: 0px 2px 0px 45px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\"><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">每个 namespace 中的 pid 是有自己的 pid=1 的进程(类似 /sbin/init 进程)</li><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">每个 namespace 中的进程只能影响自己的同一个 namespace 或子 namespace 中的进程</li><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">因为 /proc 包含正在运行的进程，因此在 container 中的 pseudo-filesystem 的 /proc 目录只能看到自己 namespace 中的进程</li><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">因为 namespace 允许嵌套，父 namespace 可以影响子 namespace 的进程，所以子 namespace 的进程可以在父 namespace 中看到，但是具有不同的 pid</li></ul><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">参考文档：<a href=\"https://blog.jtlebi.fr/2014/01/05/introduction-to-linux-namespaces-part-3-pid/\" style=\"padding: 0px; margin: 0px; text-decoration: none; color: rgb(0, 95, 169);\">Introduction to Linux namespaces – Part 3: PID</a></p><h4 style=\"padding: 0px; margin: 5px auto; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\">mnt namespace</h4><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">类似 chroot，将一个进程放到一个特定的目录执行。mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个 namespace 中的 container 在 /proc/mounts 的信息只包含所在 namespace 的 mount point。</p><h4 style=\"padding: 0px; margin: 5px auto; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\">net namespace</h4><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">网络隔离是通过 net namespace 实现的， 每个 net namespace 有独立的 network devices, IP addresses, IP routing tables, /proc/net 目录。这样每个 container 的网络就能隔离开来。 docker 默认采用 veth 的方式将 container 中的虚拟网卡同 host 上的一个 docker bridge 连接在一起。</p><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">参考文档：<a href=\"https://blog.jtlebi.fr/2014/01/19/introduction-to-linux-namespaces-part-5-net/\" style=\"padding: 0px; margin: 0px; text-decoration: none; color: rgb(0, 95, 169);\">Introduction to Linux namespaces – Part 5: NET</a></p><h4 style=\"padding: 0px; margin: 5px auto; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\">uts namespace</h4><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">UTS (\"UNIX Time-sharing System\") namespace 允许每个 container 拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程。</p><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">参考文档：<a href=\"https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/\" style=\"padding: 0px; margin: 0px; text-decoration: none; color: rgb(0, 95, 169);\">Introduction to Linux namespaces – Part 1: UTS</a></p><h4 style=\"padding: 0px; margin: 5px auto; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\">ipc namespace</h4><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">container 中进程交互还是采用 Linux 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是 host 上具有相同 pid namespace 中的进程间交互，因此需要在IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。</p><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">参考文档：<a href=\"https://blog.jtlebi.fr/2013/12/28/introduction-to-linux-namespaces-part-2-ipc/\" style=\"padding: 0px; margin: 0px; text-decoration: none; color: rgb(0, 95, 169);\">Introduction to Linux namespaces – Part 2: IPC</a></p><h4 style=\"padding: 0px; margin: 5px auto; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\">user namespace</h4><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。</p><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">有了以上 6 种 namespace 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - cgroup。</p><h4 style=\"padding: 0px; margin: 5px auto; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\">Reference</h4><ul style=\"padding: 0px; margin: 0px 2px 0px 45px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\"><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\"><a href=\"http://tiewei.github.io/cloud/Docker-Getting-Start/\" style=\"padding: 0px; margin: 0px; text-decoration: none; color: rgb(0, 95, 169);\">Docker Getting Start: Related Knowledge</a></li><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\"><a href=\"https://ruby-china.org/topics/22004\" style=\"padding: 0px; margin: 0px; text-decoration: none; color: rgb(0, 95, 169);\">Docker 介绍以及其相关术语、底层原理和技术</a></li></ul><h3 style=\"padding: 0px; margin: 5px auto; line-height: 25.2px; font-size: 14px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; widows: 1; background-color: rgb(250, 250, 250);\">1.6 资源配额「cgroups」</h3><p style=\"padding: 0px; margin: 10px 0px; line-height: 25.2px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);\">cgroups 实现了对资源的配额和度量。 cgroups 的使用非常简单，提供类似文件的接口，在 /cgroup 目录下新建一个文件夹即可新建一个 group，在此文件夹中新建 task 文件，并将 pid 写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子 subsystem ，{子系统前缀}.{资源项} 是典型的配置方法， 如 memory.usageinbytes 就定义了该 group 在 subsystem memory 中的一个内存限制选项。 另外，cgroups 中的 subsystem 可以随意组合，一个 subsystem 可以在不同的 group 中，也可以一个 group 包含多个 subsystem - 也就是说一个 subsystem。</p><ul style=\"padding: 0px; margin: 0px 2px 0px 45px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; line-height: 25.2px; widows: 1; background-color: rgb(250, 250, 250);\"><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">memory<ul style=\"padding: 0px; margin: 0px 2px 0px 45px;\"><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">内存相关的限制</li></ul></li><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">cpu<ul style=\"padding: 0px; margin: 0px 2px 0px 45px;\"><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">在 cgroup 中，并不能像硬件虚拟化方案一样能够定义 CPU 能力，但是能够定义 CPU 轮转的优先级，因此具有较高 CPU 优先级的进程会更可能得到 CPU 运算。 通过将参数写入 cpu.shares ,即可定义改 cgroup 的 CPU 优先级 - 这里是一个相对权重，而非绝对值</li></ul></li><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">blkio<ul style=\"padding: 0px; margin: 0px 2px 0px 45px;\"><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">block IO 相关的统计和限制，byte/operation 统计和限制 (IOPS 等)，读写速度限制等，但是这里主要统计的都是同步 IO</li></ul></li><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">devices<ul style=\"padding: 0px; margin: 0px 2px 0px 45px;\"><li style=\"padding: 0px; margin: 0px; line-height: 25.2px;\">设备权限限制</li></ul></li></ul>"
    }
  ]
}