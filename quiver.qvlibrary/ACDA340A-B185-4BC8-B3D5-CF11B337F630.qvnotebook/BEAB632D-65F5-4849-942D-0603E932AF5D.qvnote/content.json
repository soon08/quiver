{
  "title": "sync",
  "cells": [
    {
      "type": "text",
      "data": "<h1 cid=\"c5\" mdtype=\"heading\" class=\"md-end-block md-heading md-focus\" style=\"box-sizing: border-box; font-size: 2.25em; position: relative; margin-top: 1rem; margin-bottom: 1rem; line-height: 1.2; cursor: text; padding-bottom: 0.3em; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(238, 238, 238); width: inherit; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><span md-inline=\"plain\" class=\"md-expand\" style=\"box-sizing: border-box;\">线程同步</span></h1><h4 cid=\"c7\" mdtype=\"heading\" class=\"md-end-block md-heading\" style=\"box-sizing: border-box; font-size: 1.25em; position: relative; margin-top: 1rem; margin-bottom: 1rem; line-height: 1.4; cursor: text; width: inherit; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">线程同步的方法</span></h4><ul class=\"ul-list\" cid=\"c8\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0.8em 0px; padding-left: 30px; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><li cid=\"c9\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c10\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c11\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">原子操作</span></span></p></li><li cid=\"c12\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c13\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c14\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">互斥量 —— 只允许一个线程处于临界区的约束被称为互斥量（mutex）</span></span></p><ul class=\"ul-list\" cid=\"c15\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0px; padding-left: 30px;\"><li cid=\"c16\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c17\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c18\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">每个线程进入该代码区域的时候都需要先锁定这个互斥量，否则无法进入，只能等待</span></span></p></li><li cid=\"c19\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c20\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c21\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">线程离开临界区的时候需要解锁该互斥量，此时其他线程才可以成功锁定该互斥量</span></span></p></li><li cid=\"c22\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c23\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c24\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">互斥量也属于共享资源，能被其他线程访问，所以互斥量一般都不是局部的</span></span></p></li><li cid=\"c25\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c26\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c27\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">尽量不要让不同互斥量保护的临界区重叠，这很可能会照成死锁，即使要也要使获取互斥量的顺序相同</span></span></p></li></ul></li><li cid=\"c28\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c29\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c30\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量——在共享数据发生变化时，通知其他因此而阻塞的线程</span></span></p><ul class=\"ul-list\" cid=\"c31\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0px; padding-left: 30px;\"><li cid=\"c32\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c33\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c34\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量总是和互斥量共同使用，互斥量用于提供临界区保护，条件变量用于向其他线程通知共享变量的变化</span></span></p></li></ul><blockquote cid=\"c35\" mdtype=\"blockquote\" style=\"box-sizing: border-box; margin-top: 0.8em; margin-bottom: 0.8em;\"><p cid=\"c36\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0px 0px 0.5rem; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c37\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量的使用场景</span></span></p><p cid=\"c38\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c39\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">有一个共享队列，多个消费者从队列中并发读取数据，同时又多个生产者并发这向队列中写入数据。生产者写入数据前会先获取一个锁，判断队列是否满，如果满那么就直接解锁，否者向队列写入数据。消费者在获取数据前，会先获取一个锁，判断队列是否为空，如果为空直接解锁，否者从队列中取出一个数据。这个过程中，如果队列已满，生产者会重复获取释放锁，但是却没有写入任何数据。如果队列为空，消费者会重复获取和释放锁，但是却没有获取到任何数据。这会造成CPU资源浪费。</span></span></p><p cid=\"c40\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c41\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量就是在这种情况下产生的，避免生产者或者消费者重复获取和释放锁。</span></span></p><p cid=\"c42\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c43\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">条件变量根据一个锁创建的，如果生产者不满足条件，会先释放锁，并将线程阻塞，当条件变量获取到激活通知后，重新获取锁，并将阻塞的线程激活。</span></span></p></blockquote></li></ul><h4 cid=\"c44\" mdtype=\"heading\" class=\"md-end-block md-heading\" style=\"box-sizing: border-box; font-size: 1.25em; position: relative; margin-top: 1rem; margin-bottom: 1rem; line-height: 1.4; cursor: text; width: inherit; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">优化并发性能</span></h4><ul class=\"ul-list\" cid=\"c45\" mdtype=\"list\" data-mark=\"-\" style=\"box-sizing: border-box; margin: 0.8em 0px 0px; padding-left: 30px; font-family: 'Open Sans', 'Clear Sans', 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 16px; white-space: pre-wrap; background-color: rgb(255, 255, 255);\"><li cid=\"c46\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c47\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c48\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">控制临界区纯度，将不需要同步的代码屏蔽在外</span></span></p></li><li cid=\"c49\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c50\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c51\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">控制临界区粒度，尽量合并相邻的多个临界区为一个临界区，减少协调发生次数</span></span></p></li><li cid=\"c52\" mdtype=\"list_item\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c53\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block\" cid=\"c54\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">减少临界区中的代码执行时间，将执行时间长的代码单独到一个临界区</span></span></p></li><li cid=\"c55\" mdtype=\"list_item\" class=\"\" style=\"box-sizing: border-box; margin: 0px; position: relative;\"><p cid=\"c56\" mdtype=\"paragraph\" style=\"box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; margin: 0.5rem 0px; width: inherit; position: relative;\"><span class=\"md-line md-end-block md-focus\" cid=\"c57\" mdtype=\"line\" style=\"box-sizing: border-box; display: block;\"><span md-inline=\"plain\" style=\"box-sizing: border-box;\">优先使用原子操作而不是临界区</span></span></p></li></ul>"
    }
  ]
}