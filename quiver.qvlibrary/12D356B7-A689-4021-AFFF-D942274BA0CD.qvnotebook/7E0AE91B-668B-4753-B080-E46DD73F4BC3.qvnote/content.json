{
  "title": "生成器",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">在《深入浅出Node.js》的第4章里，笔者深入地介绍了当前盛行在Node和前端JavaScript中的几种异步编程的解决方案，唯独对Generator的解决方案没有介绍。但随着Node版本的升级和ECMAScript harmony的特性不断得到支持，在0.11版本中，我们可以通过启用<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">--harmory</code>参数让V8支持Generator。最近Connect/Express背后的开发团队也将精力转移到新的库和框架上，这个核心库和框架就是<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">co</code>和<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">koa</code>，它们最主要的特点主要就是基于ECMAScript harmony中的Generator特性，这使得它在异步编程方面有较优雅的实现。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">本文将深度介绍下Generator是如何实现将异步编程从原始的嵌套式代码转换成扁平的顺序式代码。</p><h2 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 24px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">异步编程问题回顾</h2><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">简单地回顾下，异步编程的问题主要有两个：一个是必须通过回调函数进行返回值的处理，另一个是复杂情况下会造成嵌套过深。下面简单的给出两种典型的异步场景。</p><div class=\"clear\" style=\"margin: 0px; padding: 0px; border: 0px; height: 0px; clear: both; font-size: 0px; color: rgb(0, 0, 0); font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"></div><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">异步串行读取文件：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">fs.readFile('file1.txt', 'utf8', function (err, txt) {\n  if (err) {\n    throw err;\n  }\n  fs.readFile(txt, 'utf8', function (err, content) {\n    if (err) {\n      throw err;\n    }\n    console.log(content);\n  });\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">异步并行读取文件：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">fs.readFile('file1.txt', 'utf8', function (err, txt) {\n  if (err) {\n    throw err;\n  }\n  console.log(txt);\n});\nfs.readFile('file2.txt', 'utf8', function (err, content) {\n  if (err) {\n    throw err;\n  }\n  console.log(content);\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">上述两种场景下，可以看到串行时由于代码嵌套，调用越多，会造成代码越糟糕。对于异步并行读取文件的代码，难点是无法获知并行异步调用完全完成的时间点，要解决这个问题需要借助各种异步流程库。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">目前解决异步流程控制问题的主流方案有以下三种：</p><ol style=\"margin: 10px 0px 10px 10px; padding: 0px 0px 0px 20px; border: 0px; width: 549px; clear: left; color: rgb(0, 0, 0); font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; line-height: 25.2px; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><li style=\"margin: 4px 0px; padding: 0px 0px 0px 10px; border: none; float: none; clear: none; text-align: left;\">自定义事件式方案</li><li style=\"margin: 4px 0px; padding: 0px 0px 0px 10px; border: none; float: none; clear: none; text-align: left;\">Promise/Deferred</li><li style=\"margin: 4px 0px; padding: 0px 0px 0px 10px; border: none; float: none; clear: none; text-align: left;\">高阶函数篡改回调函数</li></ol><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">由于在《异步编程》章节中已经充分介绍了上述三种方式的实现形式，这里不再详细展开三种方式的细节。但是为了行文承前启后，这里简单回顾下第三种方案的实现。</p><h3 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 18px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 36px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">高阶函数在异步编程中的使用</h3><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">高阶函数在异步编程中的使用，最广泛、最知名的莫过于<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">async</code>和<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">step</code>这两个库，它将用户正常传递进来的回调函数替换成自己包装了特殊逻辑的函数，然后再传递给异步调用。当异步调用结束后，先执行的是特殊逻辑，然后才是用户传入的回调函数。以一个简单的场景为例，假设需要等待所有异步回调执行完成后，才能执行某个逻辑，这时通过高阶函数篡改回调函数的方式就大为受用，也相当简单。以下为简单实现：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var pending = (function () {\n  var count = 0;\n  return function (callback) {\n    count++;\n    return function () {\n      count--;\n      if (count === 0) {\n        callback();\n      }\n    };\n  };\n}());\n\nvar done = pending(function () {\n  console.log('all is over');\n});\n\nfs.readFile('file1.txt', 'utf8', done());\nfs.readFile('file2.txt', 'utf8', done());\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">上述代码中，<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">done</code>执行了两次，每次执行的过程中，将计数器<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">count</code>加一，然后返回一个函数。当<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">fs.readFile</code>这个异步调用结束后，<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">done</code>执行后的回调函数会得到执行，计数器减一。当计数器回到0的时候，意味着多个异步调用的回调函数都已经执行，此时执行传入的回调函数。因为非阻塞的原因，<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">done()</code>生成的函数不会立即执行，使得计数器可以正常地增加值，结束后才慢慢减少值。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">抛开异步调用不谈，高阶函数的试用上，要让用户传入的函数能得到执行。需要如下这种方式的调用：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var done = pending(function () {\n  console.log('all is over');\n});\n\ndone()();\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">这里生成的函数被立即调用了，<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">count</code>这个计数器加一后，立即减一，然后触发等于零的条件，于是回调函数被执行了。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">在通过Generator解决异步编程问题的方案中，高阶函数与Generator之间会产生相当微妙的化学反应。</p><h2 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 24px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><a href=\"http://www.infoq.com/cn/articles/generator-and-asynchronous-programming#generator%E6%89%AB%E7%9B%B2\" name=\"user-content-generator%E6%89%AB%E7%9B%B2\" style=\"text-decoration: none; color: rgb(40, 106, 178); outline: none !important; margin: 0px; border: 0px; padding: 0px;\"></a>Generator扫盲</h2><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">Generator的中文翻译是生成器，它是ECMAScript6（代号harmory）中提供的新特性。在过去，封装一段运算逻辑的单元是函数。函数只存在“没有被调用”或者“被调用”的情况，不存在一个函数被执行之后还能暂停的情况，而Generator的出现让这种情况成为可能。</p><h3 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 18px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 36px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">Generator的定义</h3><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">Generator的定义十分简单，与普通的函数相比，它只多出一个<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">*</code>号。以下为简单例子：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var compute = function* (a, b) {\n  var sum = a + b;\n  console.log(sum);\n  var c = a - b;\n  console.log(c);\n  var d = a * b;\n  console.log(d);\n  var e = a / b;\n  console.log(e);\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">这个星号只要出现在关键字<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">function</code>和函数名之间即可。如果是匿名函数，出现在<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">function</code>和参数列表的起始括号之间即可。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">定义的Generator实际上可以理解为定义了一种特殊的数据结构，要得到Generator实例，还需要执行它一次：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var generator = compute(4, 2);\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">这样我们能得到一个Generator对象。Generator对象具有一个<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">next</code>方法。要使得定义中封装的代码逻辑得到执行，还得需要调用一次<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">next</code>方法才行。</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">generator.next();\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">调用之后的输出结果如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">$ node --harmony-generators examples/compute.js \n6\n2\n8\n2\n</pre><h3 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 18px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 36px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">yield关键字</h3><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">单独地介绍Generator没有太大价值，因为它除了更复杂外，功能与普通函数没有太大差别。真正让Generator具有价值的是<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字，这个<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字让Generator内部的逻辑能够切割成多个部分。下面是简单的示例：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var compute = function* (a, b) {\n  var sum = a + b;\n  yield console.log(sum);\n  var c = a - b;\n  yield console.log(c);\n  var d = a * b;\n  yield console.log(d);\n  var e = a / b;\n  console.log(e);\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">加入<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字后，我们继续将其实例化，然后调用<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>方法：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var generator = compute(4, 2);\ngenerator.next();\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">可以看到输出如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">$ node --harmony-generators examples/compute.js \n6\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">上面的输出意味着代码执行到第一个<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字的时候就停止了。要让业务逻辑继续执行完，需要反复调用<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>。</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var generator = compute(4, 2);\ngenerator.next(); // 6\ngenerator.next(); // 2\ngenerator.next(); // 8\ngenerator.next(); // 2\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">可以简单地理解为<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字将程序逻辑划分成几部分，每次<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>执行时执行一部分。这使得程序的执行单元再也不是函数，复杂的逻辑可以通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>来暂停。从朴素的角度来看，这类似于将一个函数的逻辑分拆为四个函数，但它们共享上下文。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>除了切割逻辑外，它与<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>的行为息息相关。每次<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>调用时，返回一个对象，这个对象具备两个属性，其中一个属性是布尔型的<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">done</code>。它表示这个Generator对象的逻辑块是否执行完成。另一个属性是<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">value</code>，它来自于<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>语句后的表达式的结果。我们将代码简单修改，可以看到效果：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var compute = function* (a, b) {\n  var sum = a + b;\n  yield sum;\n  var c = a - b;\n  yield c;\n  var d = a * b;\n  yield d;\n  var e = a / b;\n  return e;\n};\nvar generator = compute(4, 2);\nconsole.log(generator.next()); // { value: 6, done: false }\nconsole.log(generator.next()); // { value: 2, done: false }\nconsole.log(generator.next()); // { value: 8, done: false }\nconsole.log(generator.next()); // { value: 2, done: true }\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">上述是<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>对<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>行为的影响，反之，<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>也能影响到<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>。可以简单地猜测下如下代码中会打印出什么结果：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var compute = function* (a, b) {\n  var foo = yield a + b;\n  console.log(foo);\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">也许读者会以为是<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">a + b</code>的值，但是这里不是：默认情况下，这个<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">foo</code>打印出来是<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">undefined</code>。那么<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>如何影响<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>的呢？答案在于可以通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>传递参数，赋值给<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字前面的变量声明。见下面的简单示例：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var compute = function* (a, b) {\n  var foo = yield a + b;\n  console.log(foo);\n};\n\nvar generator = compute(4, 2);\ngenerator.next();\ngenerator.next(\"Hello world!\"); // Hello world!\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">所以，对于Generator而言，它不仅可以将逻辑的单元切分得更细外，还能在暂停和继续执行的间隔中，动态传入数据，使得代码逻辑可以更灵活。相比普通函数，Generator的特性相当令人期待。</p><h2 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 24px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">Generator与异步编程</h2><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">初见之下，Generator似乎与异步编程之间还八竿子打不着。但前文的高阶函数和Generator的介绍已经为我们准备好了基础。我们继续揭开Generator是如何与异步编程摩擦出闪亮的火花的。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">在拥有了<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字后，我们可以很巧妙地处理异步调用的回调函数。以顺序读取两个文件的场景为例：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">fs.readFile('file1.txt', 'utf8', function (err, txt) {\n  if (err) {\n    throw err;\n  }\n  fs.readFile(txt, 'utf8', function (err, content) {\n    if (err) {\n      throw err;\n    }\n    console.log(content);\n  });\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">如果我们要完成这两个操作，而且不以嵌套的方式进行，我们可以很自然想到以<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>来分割两个操作。</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var flow = function* () {\n  var txt = yield fs.readFile('file1.txt', 'utf8');\n  var content = yield fs.readFile(txt, 'utf8');\n  console.log(content);\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">这里虽然没有写入回调函数，但我们可以想象，如果回调函数执行的时候触发这个Generator执行一次<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>，然后将返回结果通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next(result)</code>这样的形式传入，这样尽管是异步调用，但代码编写形式已经近乎顺序式了。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">想象是美好的，现实能否实现是另一回事。要完成上面的目的，需要做的事情有两步：</p><ol style=\"margin: 10px 0px 10px 10px; padding: 0px 0px 0px 20px; border: 0px; width: 549px; clear: left; color: rgb(0, 0, 0); font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-size: 14px; font-variant-ligatures: normal; line-height: 25.2px; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><li style=\"margin: 4px 0px; padding: 0px 0px 0px 10px; border: none; float: none; clear: none; text-align: left;\">需要在回调函数中置入逻辑，用于收集回调函数传递的数据。</li><li style=\"margin: 4px 0px; padding: 0px 0px 0px 10px; border: none; float: none; clear: none; text-align: left;\">通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>传入异步执行的结果，传递给<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>，让业务流程继续进行。</li></ol><h3 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 18px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 36px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">改造异步方法</h3><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">为了完成收集异步调用的结果数据，我们必须得借助高阶函数。如下是一个修改回调函数逻辑的函数：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var helper = function (fn) {\n  return function () {\n    var args = [].slice.call(arguments);\n    var pass;\n    args.push(function () { // 在回调函数中植入收集逻辑\n      if (pass) {\n        pass.apply(null, arguments);\n      }\n    });\n    fn.apply(null, args);\n\n    return function (fn) { // 传入一个收集函数\n      pass = fn;\n    };\n  };\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">这个函数的参数是一个异步调用函数，调用之后，得到一个新的函数，这个函数在重新整理了参数列表后，添加了一个实际被调用到的回调函数。这个新的函数执行后，会调用真正的异步函数，然后再次返回一个函数，最后返回的函数的作用是为了随时注入新的逻辑（<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">pass</code>）。在参数列表后添加的回调函数中，它会将结果传递给最终给到的函数。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">用语言来解释这段代码有点吃力，我们以<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">fs.readFile</code>调用为实际例子，重点参见下文的注释：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var readFile = helper(fs.readFile);\n// =&gt; \n// function () {\n//   var args = [].slice.call(arguments);\n//   var pass;\n//   args.push(function () { // 在回调函数中植入收集逻辑\n//     if (pass) {\n//       pass.apply(null, arguments);\n//     }\n//   });\n//   fn.apply(null, args);\n//\n//   return function (fn) { // 传入一个收集函数\n//     pass = fn;\n//   };\n// }\n\nvar flow = function* () {\n  var txt = yield readFile('file1.txt', 'utf8');\n  console.log(txt);\n};\n\nvar generator = flow();\nvar ret = generator.next(); // 执行readFile('file1.txt', 'utf8');\n// ret.value =&gt;\n// function (fn) {\n//   pass = fn;\n// }\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">可以看到上面的代码，我们已经成功的将<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">flow</code>这个Generator的第一部分代码执行起来，我们可以通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">ret.value</code>来尝试植入一段特殊的逻辑，同时在异步调用结束后，将数据取出，同时执行Generator的下一部分逻辑。完整代码如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var generator = flow();\nvar ret = generator.next(); // 执行readFile('file1.txt', 'utf8');\nret.value(function (err, data) {\n  if (err) {\n    throw err;\n  }\n  generator.next(data);\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">通过这样置入特殊逻辑后，使得<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">flow</code>中的代码能够按期望顺利执行，通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>巧妙地将回调函数得到的值转换为类似返回值。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">为了让所有的Generator能适应这种情况，我们设计一个流程控制函数，用来专门控制此类操作。</p><h3 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 18px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 36px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">设计流程控制函数</h3><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">为了向TJ大神致敬，这个函数我们暂时命名为<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">co</code>。它要进行的操作是让Generator启动，在Generator暂停的时候，植入逻辑。简单实现如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var co = function (flow) {\n  var generator = flow();\n  var next = function (data) {\n    var result = generator.next(data);\n    if (!result.done) {\n      result.value(function (err, data) {\n        if (err) {\n          throw err;\n        }\n        next(data);\n      });\n    }\n  };\n  next();\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">代码中通过递归调用来完成Generator中流程的执行，调用示例如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">co(function* () {\n  var txt = yield readFile('file1.txt', 'utf8');\n  console.log(txt);\n  var txt2 = yield readFile('file2.txt', 'utf8');\n  console.log(txt2);\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">执行结果如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">$ node --harmony-generators flow.js \nI am file1.\n\nI am file2.\n\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">如此我们就完成从嵌套函数的写法转换为顺序式的编写，深度嵌套带来的“地狱之门”将成为历史。</p><h3 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 18px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 36px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">并行执行</h3><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">前面的例子中，已经成功地将嵌套代码转换为顺序的扁平的代码，但是异步调用之间仍然是串行执行，这使得我们无法享受到Node中并行I/O的好处。为此我们还需要改进<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">co</code>函数，使得异步调用能并行执行，同时依旧保证代码的顺序。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">为此，我们约定当<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>后的表达式结果是一个数组时，表示里面为多个异步调用。简单的修改如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var co = function (flow) {\n  var generator = flow();\n  var next = function (data) {\n    var ret = generator.next(data);\n    if (!ret.done) {\n      if (Array.isArray(ret.value)) {\n        var count = 0;\n        var results = [];\n        ret.value.forEach(function (item, index) {\n          count++;\n          item(function (err, data) {\n            count--;\n            if (err) {\n              throw err;\n            }\n            results[index] = data;\n            if (count === 0) {\n              next(results);\n            }\n          });\n        });\n      } else {\n        ret.value(function (err, data) {\n          if (err) {\n            throw err;\n          }\n          next(data);\n        });\n      }\n    }\n  };\n  next();\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">调用示例如下，当为数组时，应当并行执行：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">co(function* () {\n  var results = yield [readFile('file1.txt', 'utf8'), readFile('file2.txt', 'utf8')];\n  console.log(results[0]);\n  console.log(results[1]);\n  var file3 = yield readFile('file3.txt', 'utf8');\n  console.log(file3);\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">执行结果如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">$ node --harmony-generators parallel.js \nI am file1.\n\nI am file2.\n\nI am file3.\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">为了验证异步调用是并行进行的，我们换用定时器来测试：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var _sleep = function (ms, fn) {\n  setTimeout(fn, ms);\n};\nvar sleep = helper(_sleep);\n\nco(function* () {\n  console.time('sleep1');\n  yield sleep(1000);\n  yield sleep(1000);\n  console.timeEnd('sleep1');\n  console.time('sleep2');\n  yield [sleep(1000), sleep(1000)];\n  console.timeEnd('sleep2');\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">执行结果如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">$ node --harmony-generators sleep.js \nsleep1: 2004ms\nsleep2: 1005ms\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">从<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">sleep2</code>的输出来看，<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字后的数组中的所有异步调用得到并行执行。</p><h2 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 24px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">小结</h2><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">至此，我们小结一下通过Generator进行流程控制的几个要点。首先，每个异步方法都需要标准化为<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字能接受的方法，使我们有机会注入特殊逻辑，这个过程被TJ称为<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">thunkify</code>。其次，需要巧妙地将异步调用执行完成得到的结果通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">.next()</code>传递给下一段流程。最后，需要递归地将业务逻辑执行完成。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">需要注意的是<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>只能暂停Generator内部的逻辑，它并不是真正暂停整个线程，Generator外的业务逻辑依然会继续执行下去。</p><h2 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 24px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">向下兼容</h2><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">我们知道Generator和<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>关键字的特性来自于ECMAScript6，这意味着目前Node主流的0.10版本上无法享受到这些令人激动的特性；另外，Generator的语法与现行的语法不兼容，导致无法进行shim式的兼容。但是事情也并不绝对，这些难题并不能难倒geek们丰富的想象力。来自Facebook的工程师发布了一个<a href=\"http://facebook.github.io/regenerator/\" style=\"text-decoration: none; color: rgb(40, 106, 178); outline: none !important; margin: 0px; border: 0px; padding: 0px;\">regenerator</a>的工具，它将ECMAScript6中的Generator和<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>语法重新编译，使得编译出的代码能够在ECMAScript5下执行，同时达到相同的效果。</p><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">下面的代码，我们尝试通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">regenerator</code>进行编译：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var flow = function* () {\n  console.time('sleep1');\n  yield sleep(1000);\n  yield sleep(1000);\n  console.timeEnd('sleep1');\n  console.time('sleep2');\n  yield [sleep(1000), sleep(1000)];\n  console.timeEnd('sleep2');\n};\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">结果如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">var flow = wrapGenerator.mark(function() {\n  return wrapGenerator(function($ctx0) {\n    while (1) switch ($ctx0.prev = $ctx0.next) {\n    case 0:\n      console.time('sleep1');\n      $ctx0.next = 3;\n      return sleep(1000);\n    case 3:\n      $ctx0.next = 5;\n      return sleep(1000);\n    case 5:\n      console.timeEnd('sleep1');\n      console.time('sleep2');\n      $ctx0.next = 9;\n      return [sleep(1000), sleep(1000)];\n    case 9:\n      console.timeEnd('sleep2');\n    case 10:\n    case \"end\":\n      return $ctx0.stop();\n    }\n  }, this);\n});\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">这段代码中的<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">wrapGenerator.mark</code>和<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">wrapGenerator</code>来自于<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">regenerator</code>生成的依赖中，由于代码太多，暂不给出。如需查看，可以尝试以下命令：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">$ regenerator -r generator.js\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">如果编写的模块想兼容ECMAScript5和ECMAScript6，可以尝试通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">regenerator</code>生成两套代码，在ECMAScript5下，引入编译后的代码，在ECMAScript6下，引入Generator和<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">yield</code>语法的代码。示例如下：</p><pre style=\"margin-top: 10px; margin-bottom: 10px; padding: 10px 10px 10px 5px; border: 1px solid rgb(232, 232, 232); font-family: Consolas, Monaco, 'Andale Mono', monospace; color: rgb(49, 78, 100); line-height: 21px; width: 597.797px; overflow: auto; clear: none; font-size: 14px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(245, 242, 240); float: none !important; background-position: -29px 0px;\">module.exports = supportES6 ? require('./lib/index.js') : require('./es5/index.js');\n</pre><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">如果要直接体验Generator的特性，可以尝试安装<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">gnode</code>这个模块。它的原理在0.11.x的版本上是启用<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">--harmory-generators</code>，在0.10.x下则是调用<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">regenerator</code>将代码编译为ECMAScript5支持的代码，然后再执行。</p><h2 style=\"margin: 0px 0px 10px; padding: 0px; font-size: 20px; font-weight: normal; border: 0px; float: none; clear: none; width: 610px; color: rgb(34, 34, 34); line-height: 24px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">总结</h2><p style=\"margin: 0px 0px 15px; padding: 0px; border: 0px; float: none; font-size: 14px; line-height: 25.2px; color: rgb(0, 0, 0); clear: none; width: 610px; font-family: 'Lantinghei SC', 'Open Sans', Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 微软雅黑, STHeiti, 'WenQuanYi Micro Hei', SimSun, Helvetica, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">Generator的出现，使得流程控制可以更细腻，通过<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">co</code>和<code style=\"border: 0px; padding-top: 0px; padding-bottom: 0px;\">suspend</code>库，我们几乎已经完全实现了流程控制的线性处理，同时还能享受到并行异步的性能提升，在不损失性能的情况下，大大提升了编程体验。简单而言，即使只为这个特性，ECMAScript6也值得期待。</p>"
    }
  ]
}